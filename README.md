# Задание 3. Машина Тьюринга

Вам необходимо реализовать эмулятор [Машины Тьюринга](https://nerc.itmo.ru/wiki/index.php?title=%D0%9C%D0%B0%D1%88%D0%B8%D0%BD%D0%B0_%D0%A2%D1%8C%D1%8E%D1%80%D0%B8%D0%BD%D0%B3%D0%B0).

Для простоты будем считать, что 
* На ленте может быть записан любой `Char`.
* Входное слово может состоять из любых символов, кроме символа с кодом `0`.
* В качестве пробельного (blank) символа на ленте используется символ с кодом `0` (есть соответствующая константа в `Definitions.kt`) и все свободные ячейки ленты заполнены этим символом.
* В качестве состояния машины может использоваться любая строка типа `String`.
* Стартовое, допускающее и отвергающее состояния задаются при создании машины строками (названиями соответствующих состояний). 
* Функция переходов задается произвольной коллекцией типа `TransitionFunction`. 
  Если в коллекции нет перехода из состояния `s` по символу на ленте `c`, Машина Тьюринга должна перейти в отвергающее состояние и никак не поменять ленту.

## TuringMachine

Реализуйте класс `TuringMachine.Tape`, позволяющий хранить конечный подотрезок потенциально бесконечной ленты Машины Тьюринга.

* Конструктор от строки (`String`) должен создавать ленту. При использовании этого конструктора строка должна копироваться на ленту слева направо, а головка машины указывать на первый символ строки.
* Поле `content: CharArray` должно возвращать текущее содержимое ленты.
  Содержимое должно возвращаться без префикса и суффикса из символов `Blank`.
  При этом, если головка ленты указывает на какой-то символ в префиксе или суффиксе из пробельных символов, часть ленты до головки должна быть также должна попасть в `content`.
  Массив, полученный из этого поля, должен не изменяться при последующих изменениях ленты.
* Поле `position: Int` должно возвращать номер символа в массиве `content`, на который сейчас указывает головка ленты. Значение поля должно получаться за `O(1)`.
* Метод `applyTransition(char: Char, move: TapeTransition): Tape`, который записывает на текущую позицию ленты символ `char` и сдвигает головку в направлении `move`. Время работы метода должно быть `O(1)` (возможно, амортизировано).
* Метод `copy`, который создает копию ленты.
* Метод `equals`, который сравнивает ленту с другой такой же лентой. Ленты считаются равными, если они имеют одинаковый `content` и `position`.
* Метод `toString`, который выводит понятное (на ваше усмотрение) представление ленты.
* Лента должна эмулировать ленту бесконечной длины, при это для хранения использовать `O(N)` памяти, где `N` - максимальная длина `content` за все время.
* Для простоты реализации класс `Tape` может быть изменяем. То есть из `applyTransition` можно возвращать тот же экземпляр ленты, что и тот, на котором был вызван метод.

Реализуйте класс `TuringMachine.Snapshot`, хранящий в себе "снимок" состояния машины с полями `state: String` и `tape: TuringMachine.Tape`.
* Должен быть конструктор от `state` и `tape`.
* Метод `applyTransition(transition: Transition): Snapshot`, который возвращает новый "снимок" машины после применения перехода `transition`.
* Метод `equals`, который сравнивает снимок с другим снимком Машины Тьюринга.
* Метод `toString(): String`, который выводит понятное (на ваше усмотрение) представление "снимка".
* Метод `copy(): Snapshot`, который возвращает полную копию "снимка".
* Поскольку в задании выше допускается изменяемость `TuringMachine.Tape`, то и состояние ленты внутри "снимка" может измениться после `applyTransition`, что не является проблемой. 

Добавьте реализацию Машины Тьюринга в класс TuringMachine.

* Класс должен иметь конструктор с параметрами `startingState: String, acceptedState: String, rejectedState: String, transitions: Collection<TransitionFunction>`.
* Функция `initialSnapshot(input: String): Snapshot` по входному слову генерировать снимок Машины Тьюринга `Snapshot` из стартового состояния и пустой ленты, с записанным на нее словом из `input`.
* Функция `simulateStep(snapshot: Snapshot): Snapshot` должна симулировать один шаг Машины Тьюринга и по снимку `Snapshot` возвращать новый снимок `Snapshot`.
* Функция `simulate(initialString: String): Sequence<Snapshot>` должна симулировать работу Машины Тьюринга и возвращать `Sequence<Snapshot>`. 

Симуляция исполнения машины тьюринга должна происходить, пока машина не окажется в допускающем или отвергающем состоянии.
Исполнение машины тьюринга потенциально может быть бесконечным, поэтому и `Sequence<Snapshot>` может быть бесконечным.
Из-за того, что `Snapshot` изменяемый, достаточно, чтобы внутреннее состояние "снимка" внутри `Sequence` было корректным до симуляции следующего шага машины.
Один шаг симуляции Машины Тьюринга должен выполняться за `O(1)`.

При выполнении этой части задания уделите внимание
* эффективности хранения ленты и "снимков" Машины Тьюринга,
* асимптотической сложности операций симуляции и прочих,
* организации кода внутри классов,
* инкапсуляции в разрабатываемых классах.


## Main

Реализуйте примитивную консольную утилиту, симулирующую работу машины тьюринга с некоторым входным словом, в файле `Main.kt`.

Программа должна поддерживать:
* Ввод описания машины из текстового файла, переданного первым аргументом.
* Ввод входного слова из текстового файла, переданного вторым аргументом, или из консоли, если второго аргумента нет.
* Пошаговое (для выполнения каждого последующего шага нужно нажать `Enter` в консоли) или 
  автоматическое исполнение программы для машины тьюринга. Выбор режима должен происходить с помощью дополнительного аргумента `--auto`.
* Настройку задержки между шагами исполнения в автоматическом режиме. Пауза между шагами задается параметром `--delay` числом с плавающей точкой в секундах, значение по умолчанию - 0.5 секунды.
* Во время исполнения программы состояние машины после каждого шага должно выводиться в отдельной строке или нескольких строках.
  Описание состояния должно включать в себя текущее состояние и текущее содержимое ленты с выделением символа, на который указывает головка ленты.
* После завершения исполнения программы должно быть выведено конечное состояние ленты и результат (Accepted или Rejected).

Для работы с аргументами командной строки можно воспользоваться библиотекой [Clikt](https://ajalt.github.io/clikt/), она уже добавлена в проект.

Формат файла описания Машины Тьюринга может быть любым разумным. Пример описания
```text
start: state_0
accept: state_ac
reject: state_rj
blank: _
state_0 0 -> state_0  0 >
state_0 1 -> state_rj 1 ^
state_0 _ -> state_ac _ ^
```
`start` - стартовое состояние, `accept` и `reject` - допускающее и отвергающее состояние, `blank` - символ заполнитель для пустых элементов ленты (`BLANK`).
Перехода представляется, как `состояние символ -> новое_состояние новый_символ смещение`, смешение может быть `<`, `^` или `>`.

Для чтения и обработки ввода можно (но не обязательно) применять `Scanner` и другие решения стандартной библиотеки java и kotlin.

Формат вывод состояние машины после каждого шага может быть любым разумным. Пример
```text
State: state_0
_ _ 0001 _ _
       ^
```
Вам **не требуется** форматировать вывод особым образом, делать цветной вывод, очищать консоль от вывода предыдущих состояний Машины Тьюринга.
Вывод должен быть понятным, но не стоит уделять особого внимания его оформлению.

Запишите короткий gif или видео файл с демонстрацией вашего консольного интерфейса. **Прикрепите** его в PR при отправке решения.

При выполнении этой части задания уделите внимание
* работе с входными файлами,
* обработке ошибок пользователя и ввода,
* дружелюбности и понятности интерфейса,
* эффективности реализации.

## Отправка решения
Решение можно проверить с помощью тестов, которые запускаются в интерфейсе Intellij Idea или через консоль `./gradlew test` (*Nix) или `.\gradlew test` (Windows).
Убедитесь, что ваш код корректно отформатирован через `./gradlew ktlintCheck` (*Nix) или `.\gradlew ktlintCheck` (Windows).
Проблемы с форматированием можно попытаться автоматически исправить с помощью команды `./gradlew ktlintFormat` (*Nix) или `.\gradlew ktlintFormat` (Windows).

Готовое решение добавьте в ветку `solution`.
Создайте pull request с этой веткой, в качестве заголовка pull request обязательно укажите свое ФИО.
В тексте PR прикрепите картинку с демонстрацией работы консольного интерфейса. 
После создания PR убедитесь, что тесты прошли (загорелась зеленая галочка в CI).
